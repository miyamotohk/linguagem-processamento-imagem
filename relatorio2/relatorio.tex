\documentclass[a4paper, 10pt, conference]{ieeeconf}

\IEEEoverridecommandlockouts
\overrideIEEEmargins

\usepackage{graphics} % for pdf, bitmapped graphics files
\usepackage{epsfig} % for postscript graphics files
\usepackage{mathptmx} % assumes new font selection scheme installed
\usepackage{times} % assumes new font selection scheme installed
\usepackage{amsmath} % assumes amsmath package installed
\usepackage{amssymb}  % assumes amsmath package installed
\usepackage{hyperref}
\usepackage{listings}
\usepackage{subfigure}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{etoolbox}
\patchcmd{\abstract}{Abstract}{Resumo}{}{}
\patchcmd{\thebibliography}{References}{Referências}{}{}

\title{\LARGE \bf Otimizando o tempo de execução no processamento de imagens}

\author{Henrique Miyamoto e Thiago Benites \thanks{* Os arquivos do projeto estão disponíveis em \url{https://github.com/miyamotohk/linguagem-processamento-imagem}.}}

\begin{document}
\maketitle
\thispagestyle{empty}
\pagestyle{empty}

%\begin{abstract}

%Escreva aqui o resumo (abstract).

%\end{abstract}

\section{Contextualização}

%Um breve texto introdutório explicando do que se trata o documento, em uma linguagem que poderia ser entendida por qualquer pessoa que entenda programação (ou seja: referências diretas à disciplina não são desejáveis).

\textit{Threads}, assim como processos, são mecanismos que permitem que um programa execute ações de forma que elas pareçam estar sendo executadas ao mesmo tempo. A diferença entre eles é que \textit{threads} possuem área de memória compartilhada, o que não ocorre com processos \cite{alp}. Apresentamos uma comparação de desempenho entre diferentes métodos para aplicação de brilho em uma imagem. A mesma funcionalidade foi implementada de quatro maneiras diferentes: usando múltiplas \textit{threadas}, usando multiprocessos, em uma única linha de execução, varrendo a matriz por linhas e por colunas. O objetivo é comparar e discutir os desempenhos de cada método a partir do tempo de execução de sistema de cada um deles.

A tabela \ref{tabela1} apresenta as sintaxes para os diferentes métodos de aplicação de brilho usados em nosso programa.

\begin{table}[h]
	\centering
	\caption{Sintaxe para diferentes métodos de aplicação de brilho}
	\label{tabela1}
	\begin{tabular}{|c|c|}
		\hline \textbf{Método de implementação} & \textbf{Sintaxe}\\
		\hline \textit{Multithreadas} & \begin{tabular}[c]{@{}c@{}}{destino.jpg = origem.jpg *float THR}\end{tabular} \\
		\hline Multiprocessos & \begin{tabular}[c]{@{}c@{}}{destino.jpg = origem.jpg *float PRC}\end{tabular} \\ 
		\hline Varredura por linhas & \begin{tabular}[c]{@{}c@{}}{destino.jpg = origem.jpg *float LIN}\end{tabular} \\ 
		\hline Varredura por colunas & \begin{tabular}[c]{@{}c@{}}{destino.jpg = origem.jpg *float COL}\end{tabular} \\ 
		\hline
	\end{tabular}
\end{table}

\section{Demonstração}

%Entradas e saídas que demonstram as funcionalidades implementadas.

Para medição dos tempos de execução foi usada a função \texttt{gettimeofday} da biblioteca \texttt{time.h}. As tabelas a seguir apresentam os tempos de execução dos diferentes métodos, para imagens de diferentes tamanhos: pequena 32x32 pixels (\texttt{dora.jpg}), média 640x640 (\texttt{ssa.jpg}) e grande 2592x1944 (\texttt{demo.jpg}).

\begin{table}[h]
	\centering
	\caption{Tempos de execução dos métodos para imagem pequena.}
	\label{tabela2}
	\begin{tabular}{|c|c|c|}
		\hline
		\textbf{Implementação} & \textbf{Tamanho da imagem} & \textbf{Tempo de sistema (ms)} \\ \hline
		Multithreads           & 32x32                      & 3,7660                         \\ \hline
		Multiprocessos         & 32x32                      & 53,8670                        \\ \hline
		Varredura por colunas  & 32x32                      & 0,092000                       \\ \hline
		Varredura por linhas   & 32x32                      & 0,113000                       \\ \hline
	\end{tabular}
\end{table}

\begin{table}[h]
	\centering
	\caption{Tempos de execução dos métodos para imagem média.}
	\label{tabela3}
	\begin{tabular}{|c|c|c|}
		\hline
		\textbf{Implementação} & \textbf{Tamanho da imagem} & \textbf{Tempo de sistema (ms)} \\ \hline
		Multithreads           & 640x640                    & 31,2480                        \\ \hline
		Multiprocessos         & 640x640                    & 825,2130                       \\ \hline
		Varredura por colunas  & 640x640                    & 9,732000                       \\ \hline
		Varredura por linhas   & 640x640                    & 9,556000                       \\ \hline
	\end{tabular}
\end{table}

\begin{table}[]
	\centering
	\caption{Tempos de execução dos métodos para imagem grande.}
	\label{tabela4}
	\begin{tabular}{|c|c|c|}
		\hline
		\textbf{Implementação} & \textbf{Tamanho da imagem} & \textbf{Tempo de sistema (ms)} \\ \hline
		Multithreads           & 2592x1944                  & 101,4530                       \\ \hline
		Multiprocessos         & 2592x1944                  & 7188,9360                      \\ \hline
		Varredura por colunas  & 2592x1944                  & 169,008000                     \\ \hline
		Varredura por linhas   & 2592x1944                  & 147,995000                     \\ \hline
	\end{tabular}
\end{table}


\section{Análise}

%Aqui deve-se comparar a qualidade, em questão de tempo, de cada implementação. Ademais, analisar-se-ão quais métodos são vantajosos de acordo com diferentes tamanhos de imagens e de pixels fixados para análise por função.

Inicialmente, o número de \textit{threads} e processos 

Observa-se que o método com menor tempo de execução depende do tamanho da imagem utilizada. Para as imagens pequena e média, as varreduras em uma única linha de execução (por linha e por coluna) são as que apresentam melhor desempenho. No entanto, ao aplicar a funcionalidade à imagem grande, o tempo de execução do método \textit{multithread} mostra-se o menor dentre os comparados. Isso se deve provavelmente à solução de compromisso do método de múltiplas \textit{threads}: há um gasto computacional relacionado à criação delas, que, para imagens pequenas, acaba prejudicando o desempenho; para imagens grandes, no entanto, esse gasto é compensado pelo ganho de tempo da execução paralela das \textit{threads}. No caso da implementação com múltiplos processos, seu desempenho é sempre inferior ao dos demais processos. Uma possível explicação para isso é o gasto necessário para criação da área de memória compartilhada.

\begin{thebibliography}{99}

\bibitem{alp} MITCHELL, Mark; OLDHAM, Jeffrey e SAMUEL, Alex. \textit{Advanced Linux Programming}. Indianopolis: New Riders, 2001.

\end{thebibliography}

\end{document}